During this project I learned a lot, and more than I expected to learn at the start of the project. Not only did we learn to build a robot, but we also learned how to build a robot in a way more structured way. I learned that when designing something the temptation to immediately start building and implementing might be faster, but starting by about the problem and carefully documenting this gives a way more stable. and therefore reliable, result.

Beside this new work flow I also became more experience with exploring coding languages which are only partially documented. The search for answers to implementation problems is totally different. When you dive into the source code to find the functionality you need is a totally different way, but can be just as effective.

\subsection{My Experience}
If at the start of the quartile we would have received the same exercise, but this time without the V-model, we would have immediately building a sorting machine, and the day after program it. It seems not unlikely that we would have come up with a machine which would function just as good, since building it is pretty straight forward, and there would be quite a lot of time left for debugging. Even if the created machine would be just as good - or even better -, then we still would have achieved less. Not because we - most likely - created a machine consisting of layers of fixes upon fixes, but more because we made ``just a sorting machine''. What we learned was how could build and implement a sorting machine, but that all. Next time we would make a different machine we would do it in the same build-and-implement method. This new machine would also consists of a large stack of fixes, which is fine as long as this machine is also simple. But what if our next machine wouldn't be simple?

In the beginning I couldn't see, nor understand, the bigger goal of this project, the goal seemed to build a sorting machine, which I eventually valued least. Even if someone would have screamed it in my face at the first presentation, I would only know it. It would have been theory and nothing more than that. I couldn't value this theory because it seemed unnecessary, I build harder things than this sorting machine in the past, and all where made with the build-and-implement method. These projects succeeded – at least for most of them, since for some a couple of extra layers of fixes would be necessary - so why would I go through all the hassle of all these other phases and spend so much time on documenting?

This mindset only changed later on in the project, quite abrupt I realized what the actual value of this entire V-model is. When we were implementing the software of our robot we spend almost all of our time on documenting, with the only exception building the robot and getting used to programming the EV3. For weeks we thought, talked, and (if we wouldn’t know something) searched, somewhere in between we build our robot, but mostly we produced documentation. Part of our documentation was a quite complex finite state automaton, complex enough that when we were implementing it I couldn’t believe that it would just work. My experience was with building something this complex that a lot more time would be needed to debug than actually implement it. When we implemented our first version with the entire FSA I assumed that still a lot of debugging should be done, but to my surprise no major bugs where present. Only some small implementation errors, which where easy to trace and fix since it was just comparing the code with the documentation, and a nice bit of fiddling with the calibration of the light sensor. But that was it, no mayor software bugs appeared although I was still expecting them. It seemed to went too smooth, it was too easy. After thorough testing it functioned as documented, which finally made me realize that all the documenting actually payed off. We made something which functioned as intended, it had no random behaviour and it just worked.